const StylableWebpackPlugin = require('@stylable/webpack-plugin');
import path from 'path';
import webpack from 'webpack';
import glob from 'glob';
import {HTMLSnapshotPlugin} from '@stylable/webpack-extensions';
import {createElement} from 'react';
import {renderToStaticMarkup} from 'react-dom/server';
import {generateFilteringLogic} from './filter-logic';
import {mapSylesToComponents} from './map-styles-to-components';
import {getCompName, IComponentMetadata, IRegistry} from '@ui-autotools/registry';
import {consoleLog} from '@ui-autotools/utils';
import {dedent} from './dedent';
import {parseSnapshotFilename} from './filename-utils';

function findComponentByName(name: string, Registry: IRegistry): IComponentMetadata<any> | void {
    // We only have to do this because we currently map the component definitions to their metadata,
    // not the names. So we have no way to get component metadata by name. And at this point in the build
    // process, the component definition returned by webpack has been modified from the original, so we can't
    // get the metadata with it
  for (const component of Registry.metadata.components) {
      const metadata = component[1];
      if (getCompName(metadata.component) === name) {
        return metadata;
      }
    }
}

async function buildSingleFile(file: string, directory: string, filteringLogic: (stylableModule: any) => any, config: any, Registry: IRegistry) {
  const {base} = parseSnapshotFilename(file, '.snapshot.ts');

  function render(compiledFile: any, sourceFile: any) {
    const compMetadata = findComponentByName(compiledFile.default.name, Registry);

    if (!compMetadata) {
      throw new Error(`Could not find component metadata for ${compiledFile.default.name}`);
    }

    const {simIndex} = parseSnapshotFilename(sourceFile.id, '.snapshot.ts');
    const props = compMetadata.simulations[simIndex].props;
    const cssLink = `<link rel="stylesheet" type="text/css" href="${base}.css">`;
    const componentString = renderToStaticMarkup(createElement(compiledFile.default.comp, {className: compiledFile.default.style.root, ...props}));
    const template = `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>${compMetadata.exportName}</title>
      ${cssLink}
    </head>
    <body>
      ${componentString}
    </body>
    </html>`;
    return dedent(template);
  }

  const snapshotConfig = {
    entry: {
      [base]: file
    },
    target: 'node',
    output: {
      filename: '[name].js',
      pathinfo: true,
      path: directory
    },
    plugins: [
      new StylableWebpackPlugin({
        outputCSS: true,
        path: directory,
        filename: '[name].css'
      }),
      new HTMLSnapshotPlugin({
        render,
        getLogicModule: filteringLogic
    })
    ]
  };

  // TODO: should use the project's Stylable, instead of replacing it with our own Stylable plugin version
  const mergedConfig = {...config, ...snapshotConfig};
  const compiler = webpack(mergedConfig);

  return new Promise((resolve, reject) => {
    compiler.run((err) => {
      if (err) {
        reject(err);
      } else {
        console.log('here');
        resolve();
      }
    });
  });
}

export const generateSnapshots = async (processDir: string, tempDirectory: string, Registry: IRegistry) => {
  const webpackConfig = require(path.join(processDir, '.autotools/webpack.config.js'));
  const mapping = mapSylesToComponents(Registry, processDir);
  const filteringLogic = generateFilteringLogic(mapping);

  // Grab the autogenerated files
  console.log(processDir);
  console.log(tempDirectory);
  tempDirectory = path.join(process.cwd(), 'dist');
  const files = glob.sync('.autotools/tmp/*.snapshot.ts', {cwd: processDir});
  console.log('files', files);

  consoleLog('Generating snapshots...');
  for (const file of files) {
    await buildSingleFile(file, tempDirectory, filteringLogic, webpackConfig, Registry);
  }
};
